## additional information CPU概念模型基礎零件
0. 1 Byte = 8 bits, 假設是32 bits電腦, 指令位置占用32 bits也就是4 個 Byte
1. Program Counter 程式計數器: 特殊的寄存器, 用來存放下個要執行的指令位置
2. Instruction Memory 指令內存: 儲存指令
3. Register file 寄存器堆: 寄存器的集合, MIPS總共有32個寄存器
4. ALU 算術邏輯單元: 執行運算
## 指令執行步驟01:19

1. 依據Program Counter 提供的地址到內存讀取指令
2. 指令會依照指令內的器存器地址儲存在寄存器
3. 依照不同指令執行指令, 一定會經過ALU運算
    1. 運算出結果數據
    2. 運算數據內存地址
    3. 運算指令內存地址
4. 可能會需要存取數據內存
5. 結果回傳寄存器
    
3. Instruction Memory

## EXAMPLE: MISP架構概念模型: 數據路徑 04:37
1. PC: 輸入Byte地址號碼, 輸出指令地址
    - 因為指令占用4 個 Byte, 如果不是特殊指令, 原地址會直接+4到下個地址, 以讀取下條指令
2. 指令內存: 輸入指令地址, 輸出指令
    - R-type指令: 不包含數據內存的運算指令, 包含3個寄存器地址(2輸出1輸入), 一個地址5bits(最多32個地址)
    - I-type指令: 包含數據內存讀寫的指令, 包含1的地址, 1個來源地址或偏移地址, 一個地址同為5bits(內存地址另外) 
    - J-type指令: 更改PC地址號碼指令, PC會轉跳到特定地址而非原本的+4, 但仍是4的倍數, 總共26bits存放PC地址
3. 寄存器堆: 數入寄存器地址, 輸出寄存器內資料
    - R-type指令: 接收3個地址, 2個讀取資料輸出給ALU, 1個接收ALU回傳的資料
    - I-type指令: 至少接收2個5bits地址作為器存器來源或目的地址,有16bits用作內存地址或Immediate Value
3. ALU: 輸入資料, 輸出結果
    - R-type指令: 輸入兩個寄存器資料, 運算結果輸出到寄存器

## MISP架構概念模型: 控制 07:52
1. multiplexer:如果由多路輸出到同路徑, 需要有mux 選擇路徑, 有三個主要的mux
    1. ALU其中之一接收的數據是來自寄存器還是指令內存
    2. 寄存器收到的數據是來自ALU還是數據內存
    3. PC的地址是+4還是因為指令要到不同位置
2. 控制器: 指令內存也會輸出指令到控制器, 控制器依指令控制其他零件, 多數只要1bits來控制
    1. 控制multiplexer決定資料路徑
    2. 寄存器的寫入
    3. 數據內存的寫入或讀取
    4. ALU的運算(運算需要4bits)

## 邏輯設計基礎回顧 10:24
1. 低電壓 = 0, 高電壓 = 1
2. 1bit一條線, 多bits用多條線或粗線旁邊標註數量
3. 組合元件中輸出是輸入的函數: 輸入決定輸出
4. 有些組合元件還會有狀態元件: 狀態元件用於儲存狀態, 這時輸出就是輸入和狀態的函數

## 組合元件 12:18
1. gate門: and, or, not...
2. 加法器
3. mux多路轉接器: 二路 四路
4. ALU算術邏輯單元: 結合多個元件

## 指令執行 14:58
1. 第一步: PC含有32bits寄存器
2. R-type指令 15:45: 讀兩個寄存器輸出到ALU, 把從ALU回傳的數據存入一個寄存器, 一個寄存器地址5bits
    1. 寄存器內是依靠兩個mux來決定輸出, 寄存器地址同時就是mux的控制行
    2. 寫入寄存器:
        1. 控制單元決定資料是否要寫入
        2. n-to-1解碼器把5bit 地址解碼成寄存器編號
        3. 如果要控制訊號要寫入且編號正確(用與門), 數居就會接通到特定編號寫入
    3. 內存和寄存器原理類似, 只是寄存器只有32bits
3. 加載/存儲指令 19:48: 從內存讀取或寫入數據 19:48
    1. 有16bits存放內存地址, 依據5bits寄存器偏移地址找到基本地址
    2. 數據進入ALU前會有符號擴展單元將16bits的內存地址, 擴展成32bits和偏移地址進行計算, 取得32bits的內存地址
    3. 存取方式類似於寄存器
4. branch分支指令 21:43
    1. AUL讀取寄存器數據比較是否相等(beq, Bne), 相減後AUL零輸出即為相等
    2. 得到實際地址前依然會需要符號擴展, 還需要左移兩位(相當於乘4)
        - 因為指令位置一定為4的倍數, 藉此可以不需要偏移地址就能組合成足夠地址
    3. 地址加回到PC

## 單周期指令 24:23
目前所提到的流程均為單周期, 即所有部件只進行一條指令, 不會重複使用到部件

## 控制信號 26:08
1. 均由主控置單元接收指令後產生信號(\[31-26]為控制bits)
2. 多為獨立信號1bit, 不需要另外解碼
3. ALU會有另外的ALU控制單元, 會要從主控置單元接收2bits信號後和指令的\[5-0]bits組合進行解碼





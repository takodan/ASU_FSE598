# graph 圖
1. graph 定義
    1. Vertex頂點/節點: modules
    2. edge邊/線: 點和點之間的關係
    3. 節點的度: 節點有多少邊, 等於有多少相鄰節點: deg(v)
    4. 圖的度: 圖內節點度的最大值 deg(G)
    5. 孤立頂點: 沒有度的點
    6. 特殊度圖:
        1. Regular正則圖: 每個點的度相同, k度的正則圖稱為k-Regular
        2. 補圖: G的補圖是一張有相同點, 但邊相反的圖
2. graph 路徑 定義
    1. walk線路: 一系列連續的邊, 長度即為邊的數目
    2. path路徑: 不重複邊的線路
    3. trail: 不重複點的線路
    4. 特殊路徑:
        1. simple path簡單路徑: 路徑上的點不重複
        2. cycle環: 第一個和最後頂點相同的路徑
        3. 簡單環: 只有第一個和最後頂點相同的路徑
3. graph 連通性 定義
    1. 連通圖: 任兩個頂點之間都有路徑相連
    2. 連通分量: G的最大連通子圖數量, 包含孤立頂點也算一個分量
4. graph 有向圖 定義
    1. arc有向邊: 有起點終點, 或稱為尾(起點)頭(終點)
    2. 入度: 進入v頂點的邊數; 出度: 以v頂點為起點的邊數
    3. 有向路徑
5. graph 加權圖 定義
    1. 給邊加上訊息/權重
    2. 路徑權重: 邊的權重和
    3. 最短路徑: 權重和最小的路徑
    4. 根據加上的數據可能有不同解釋

# 圖的類型
1. 路徑圖p3:
    1. 包含一條路徑的圖
    2. 頂點n >= 2, 有n-1個邊
    3. Pn
2. 環圖p12:
    1. 頭尾相連的路徑圖
    2. 頂點n >= 3, 有n個邊
    3. Cn
3. Clique團圖/完全圖p13
    1. 所有頂點都有邊相連的圖
    2. 頂點n >= 2, 有n(n-1)/2個邊(每個點n要連接n-1個點, 沒有方向性所以要除掉重複的邊)
    3. Kn
    4. K3 = C3, K2 = P2
4. tree樹
    1. 不含環的連通圖, 所有節點都有邊連接但是沒有環, 點間為唯一簡單路徑
    2. 有n個節點, n-1個邊
    3. 根節點, 父節點, 子節點, 葉節點
    4. 將任意任意連通圖轉為樹: 保持連通性的同時刪除邊直到剩下n-1
    5. 轉為樹的另一個想法: 刪除環
    6. 路徑圖必為樹
5. 二分圖
    1. 如果節點可以分為兩個不相交的集LR, 而且沒有編是連接同集合中的節點, 也就是說L要接R, R要接L
    2. L, R 成為圖G的component組件
    3. 完全二分圖: 一個節點除了和自己同集合以外的節點都有邊連接: Kmn
    4. 偶數環圖必為二分圖
    5. 樹必定為二分圖

# 圖算法
1. Eulerian Graph歐拉圖:
    1. 含有一個經過所有邊的路徑
    2. 此路徑稱為歐拉路徑, 如果起點終點相同稱為歐拉環
    3. 無法找到歐拉路徑的圖稱為非歐拉圖
    4. 一個連通無向圖的頂點度是偶數, 為無向歐拉圖
    5. 一個強連通圖(有向連通圖)的入度等於出度, 為有向歐拉圖
    6. 解歐拉圖, 如果頂點度非平衡, 先看是否可以以新的邊平衡頂點度創造出歐拉環, 就可以知道歐拉路徑的起點和終點
2. Hamiltonian cycle漢米頓環
    1. 有一個環訪問每個節點一次
    2. 漢米頓環是一個NP難題
    3. 目前尚未有解單準則, 無多項式時間算法
    4. 但是有些圖仍可以簡單找到漢米頓環
3. EXAMPLE: 基因組排列問題
    1. 找到一個字串, 其所有長度為3的子字串為:
        - AGG, ATC, CAG, CAT, CCA, GCA, TCA, TCC
    2. 例如一個字串DISCRETE, 其所有長度為3的子字串為:
        - DIS, ISC, SCR, CRE, RET, ETE
    3. 找出此子字串排列順序成字串, 就是模擬基因蛋白質排列
    4. 解法:
        1. 把字串拆解為子字串簡單, 但反推可能因為重複而變複雜
        2. 有8個長度為3的子字串, 可以推反推字串長度為10
        3. 代表每個子字串有重疊2個字
        4. 所以我們要找一種排列順序:
            1. 全部子字串都有用到
            2. 一個子字串的下個子字串要有2個字重疊
        5. 轉換為重疊圖:
            1. 子字串為頂點
            2. 有向邊連到下一個可能的子字串(有2個字重疊)
            3. 要找一條路徑訪問每個節點一次, 也就是漢米頓路徑(或是環)
    5. 但是漢米頓環沒有有效算法, 在子字串數量大的時候難解
    6. 我們可以試著把頂點變成邊, 就變成解歐拉路徑
    7. de bruijn graph
        1. 把子字串拆分, 例如用CA->AT表示CAT
        2. 拆分後重複的頂點可以不用畫上, 連接頂點構成圖
        3. 解法:
            1. 找到不平衡的頂點, 得到歐拉路徑起點和終點
            2. 遍歷找到可能的歐拉路徑
    8. 這是一個特例, 不是所有漢米頓圖都能轉換為歐拉圖

# 生成樹協議STP
1. 用於network switch網路交換器
2. 透過禁止部分端口來禁止不必要連接(例如環)產生
3. 實際流程:
    1. 一個網路交換器作為"root bridge"
    2. 把其他switch連接到"root bridge"的端口作為"root port"
    3. 在每個連接中任意選擇一邊不是"根端口"作為"designated port指定端口"
    4. 關閉block沒有被選到的端口
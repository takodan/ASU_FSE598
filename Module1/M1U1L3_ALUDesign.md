## 二進制 00:38
轉換利用短除法: 十進制: 19, 二進制: 10011
```
2/ 19 = 9...1
2/ 9  = 4...1
2/ 4  = 2...0
2/ 2  = 1...0
2/ 1  = 0...1
from button to top
10011
```
加法和十進制相同, 只是變成二進位
```
  1 0 1        5
  1 1 0        6
--------  =  ----
1 0 1 1      1 1 
```
ALU只能做加法, 減法須利用補數來達成, 增加1位做為正負數表示(0正1負), 補數分為1補數, 2補數
```
1補數: 把1改成0, 0改成1
二進位0100-0011, 減數做1補數0100+1100, 得到10000益位等於0001

2補數: 把1改成0, 0改成1, 在加1
二進位0100-0011, 減數做2補數0100+1101, 得到10001益位等於0001
```
乘法類似於加法, 依靠在寄存器中位移來達成
```
   1000
   1001
  --------
   1000
  0000
 0000
1000
------
1001000
```
## MIPS ALU 02:42
1. 1bit的ALU可以接收AB各1bits的數據, 1bit的BInvert(同時接到CarryIn), 2bits的計算
2. 可以輸入2組32bits的資料, 輸出1組32bits結果
3. 另外輸入4 bits 運算
4. 另外輸出1 bits 溢出, 1 bits全零
5. 支援的邏輯
    - add, sub, mult, Div
    - and, or, not, xor
    - beq(branch on equal)
    - Bne(branch on not equal)
    - slt(set on less than)

## EXAMPLE: 乘數硬件流程 13:16 (pic)
1. 利用多次加法來達成乘法
2. 被乘數"0110" * 乘數"0101",
3. 結果寄存器共64bits, "32積"+"32乘數", 加法完成後要右移一位, 為方便下面計算只做4bits
    1. 乘數"0101"取最後一位1, 積直接加上被乘數"0110", 結果"0110"+"0101", 右移一位"0011"+"0010"
    2. 乘數"0010"取最後一位0, 積不做加法, 結果"0011"+"0010", 右移一位"0001"+"1001"
    3. 乘數"1001"取最後一位1, 積直接加上被乘數"0110", 結果"0111"+ 1001", 右移一位"0011"+"1100"
    4. 乘數"1100"取最後一位0, 積不做加法, 結果"0011"+"1100", 右移一位"0001"+"1110"
    5. 因為4bits最多也只需要4次做完乘數, 輸出結果"00011110"

## EXAMPLE: 除數硬件流程
1. 類似於乘法, 只是利用減法加法和左移
2. 被除數"0110" / 除數"0010"
3. "32餘數"+"32被除數", 同乘法例子只做4bits
    1. "0000"+"0110", 餘數=餘數-除數, 等於餘數"0000"+2補數除數"1110", 結果"1110"為負數, 餘數+除數還原後左移一位補0, 除數右移一位"0001"
    2. "0000"+"1100", 餘數"0000"+2補數除數"1111", 結果"1111"為負數, 餘數+除數還原後左移一位補0, 除數"0000"
    3. "0001"+"1000", 餘數"0001"+2補數除數"0000", 結果"0001"為正數, 不用還原左移一位補1, 除數"0000"
    4. "0011"+"0001", 餘數"0011"+2補數除數"0000", 結果"0011"為正數, 不用還原左移一位補1, 除數"0000"
    5. "0110"+"0011", 輸出結果

## additional information
1補數2補數 https://noob.tw/complements/
除法器 https://ithelp.ithome.com.tw/articles/10161144
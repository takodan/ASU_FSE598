## 分治編程 00:52
1. 以遞迴為主要方法
2. 分: 將問題拆解為多個較小的子問題
3. 治: 解決每個子問題

## 快速排序 01:54
1. 分: 取最後一個數據, 依這個數據把全部分成兩組
2. 治: 以遞迴重複直到最後沒有數據可以分成兩組
Quicksort(A,L,R)  
if R>L then  
    k := Partition(A,L,R)  
    Quicksort(A,L,k-1)  
    Quicksort(A,k+1,R)  
    A\[k\]也稱為pivot

## 實現 07:14
1. 選擇A\[R\]作為pivot, 目標是使其移動到列表中正確位置
    1. 及左邊元素均小於A\[R\], 右邊元素均大於A\[R\]
    2. 理想中選中的A\[R\]即為中間數, 但實現上可以取最右變數
2. 從最左側開始尋找一個大於等於A\[R\]的元素
3. 從右邊尋找一個小於A\[R\]元數
4. 交換兩個數
5. 重複找元數直到指針相遇
6. 把R和右邊子列表的第一個元素交換

## Partition算法 09:25
```
Partition(A, L, R)
    v := A[R]65
    i := L 7
    j := R 6
    while i < n do
        // while條件可能要改成i < j
        while A[i] < v do
            i = i+1
        while j>i and A[j] >= v do
            j := j-1
        if i < j then
            swap(A[i],A[j])
        // 或是 i = i+1 才不會進入無窮迴圈
    swap(A[i], A[R])
    return I
```
重點, O(n) 不適O(n^2)

## 實例 12:18
1. 數列: 3,7,2,6,4,1,3,5
2. pointer: 3(i),7,2,6,4,1,3,5(v)(j)
3. 先從左邊加一直到找大於(v)的數: 3,7(i),2,6,4,1,3,5(v)(j)
4. 如果(i)沒有超過(j), 再從右邊減一直到找小於(v)的數: 3,7(i),2,6,4,1,3(j),5(v)
5. 如果(i)沒有超過(j), 兩數值交換: 3,3(i),2,6,4,1,7(j),5(v)
6. 如果(i)還沒有到底, 接續加一直到找大於(v)的數: 3,3,2,6(i),4,1,7(j),5(v)
7. 如果(i)沒有超過(j), 再從右邊減一直到找小於(v)的數: 3,3,2,6(i),4,1(j),7,5(v)
8. 如果(i)沒有超過(j), 兩數值交換 3,3,2,1(i),4,6(j),7,5(v)
9. 如果(i)還沒有到底, 接續加一直到找大於(v)的數: 3,3,2,1,4,6(i)(j),7,5(v)
10. 這時(i)等於(j) 不用再找新的(j), 也不用交換(i)(j): 3,3,2,1,4,6(i)(j),7,5(v)
11. 如果最外圈條件為i < j, 代表不用再跑回圈, 可以進入13.交換(v)和(i)
12. 如果最外圈條件為i < n, 代表i會持續找到底, 但是因為i持續大於j, 所以不會有任何找j或是交換的動作, 到底進入13.交換(v)和(j)
13. 代表數列已經照(v)排好, 交換數值排序好5: 3,3,2,1,4,5,7,6
12. 5這個值已經排好不用排序了, 取出5並把數列照5的位置分為兩列: 3,3,2,1,4; 7,6
13. 再重新分配pointer, 然後開始排序3(i),3,2,1,4(v)(j); 7(i),6(v)(j)

下一步這裡我先看數列 7, 6
1. 7(i),6v(j)
2. (i)的值大於(v), i不動
3. j大於i, 且(j)等於v, j-1: 7(i)(j),6(v)
4. i=j, 所以不交換
5. 如果外圈條件為i小於j, 跳出迴圈, 交換(i),v, 數列6(i)(j), 7(v)
6. 如果外圍條件為i小於n, 在交換後i++, 仍小於n, 數列6(j),7(v)(i)
7. (i)=v, i不動
8. i>j, j不動不交換
9. i++, i = n, 迴圈結束

## 快速排序複雜度 15:16
1. 最佳情況: 找到的pivot剛好把數列切分一半: 每次n/2: n log n
2. 最壞情況: 其實數列已經排序好了, 找到的pivot剛好就是排序最右邊的數: 每次只有n-1, 還是要重複n次: n ^ 2
3. 其實除了最壞情況, 其他情況的複雜度均為n log n

## 證明快速排序複雜度 21:21

## 隨機快速排序 31:15
先隨機取一個數和A\[R\]交換, 也就是以隨機數當作pivot, 以確保最壞情況機率是隨機的, 也就在可接受範圍

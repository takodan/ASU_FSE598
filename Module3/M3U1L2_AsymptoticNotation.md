## 為什麼算法重要 00:55
因為計算機多是要處理比較複雜且大的數, 運用一般生活使用的算法效率較低 
## 運算次數計算 05:20
1. 只有常數, 一行等於一次
2. 假設兩行, 放入一個會跑n次的迴圈, 次數等於2n
3. 將2n再放入一個會跑n次的迴圈, 次數2n*n, 2n^2

## 漸進符號 07:04
1. 函數T(n): 實際計算時間, 但是我們不關心機器速度和小的n
2. 為方便知道的增長情況, 以漸進符號取代常數部分, 並只保留最高增長階

## 漸進符號定義 09:46
1. $\theta$: $\theta$(g(n)) 是f(n)的tight bound
    1. 常數C1, C2, n0
    2. 在 n >= n0
    3. 滿足 0 <= C1 g(n) <= f(n) <= C2 g(n)
    4. 白話來說: 當n大於某數, g(n)*常數作為上下界可以包含f(n)
    5. 找 $\theta$ 的難點在於可以找到差距很大的上下界但很難證明是不是tight bound
    6. 多數情況找不到 $\theta$, 只要找到 Big O, 因為我們要找最差情況
2. Big O, Big $\Omega$
    1. 常數C, n0
    2. 在 n >= n0
    3. 滿足 0 <= f(n) <= C g(n)
    4. 白話來說: Big O是上界, $\Omega$是下界, 但不一定tight bound
    5. 實際情況多只使用 Big O
3. small O, small $\Omega$
    1. 白話來說: 類似於Big, 但是一定不是tight bound
4. 僅當 $\theta$(g(n))成立, Big O, Big $\Omega$ 也成立 

## 增長階 27:13
1. 常數
2. 對數: log n
3. 多項式: 
    1. n
    2. n log n
    3. n 的常數次方
6. 指數: 
    1. 常數的n次方
    2. n!
    3. n^n

## 算法效率 35:34
1. 比較最壞情況
2. 評估不考慮較小的數
3. 只要是增長階是在多項式以下, 多半認為是高效率的
4. 如果是指數, 多半認為是低效率的